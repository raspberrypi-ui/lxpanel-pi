diff --git a/plugins/cpu/cpu.c b/plugins/cpu/cpu.c
index 22eeac0..46b8be5 100644
--- a/plugins/cpu/cpu.c
+++ b/plugins/cpu/cpu.c
@@ -65,119 +65,22 @@ typedef struct {
     GdkColor foreground_color;			/* Foreground color for drawing area */
     GdkColor background_color;			/* Background color for drawing area */
 #endif
-    GtkWidget * da;				/* Drawing area */
-    cairo_surface_t * pixmap;				/* Pixmap to be drawn on drawing area */
-
+    PluginGraph graph;
     guint timer;				/* Timer for periodic update */
-    CPUSample * stats_cpu;			/* Ring buffer of CPU utilization values */
-    unsigned int ring_cursor;			/* Cursor for ring buffer */
-    guint pixmap_width;				/* Width of drawing area pixmap; also size of ring buffer; does not include border size */
-    guint pixmap_height;			/* Height of drawing area pixmap; does not include border size */
     struct cpu_stat previous_cpu_stat;		/* Previous value of cpu_stat */
     gboolean show_percentage;				/* Display usage as a percentage */
     config_setting_t *settings;
 } CPUPlugin;
 
-static void redraw_pixmap(CPUPlugin * c);
 static gboolean cpu_update(CPUPlugin * c);
-#if !GTK_CHECK_VERSION(3, 0, 0)
-static gboolean expose_event(GtkWidget * widget, GdkEventExpose * event, CPUPlugin * c);
-#else
-static gboolean draw(GtkWidget * widget, cairo_t * cr, CPUPlugin * c);
-#endif
 
 static void cpu_destructor(gpointer user_data);
 
-/* Redraw after timer callback or resize. */
-static void redraw_pixmap(CPUPlugin * c)
-{
-#if !GTK_CHECK_VERSION(3, 0, 0)
-    GdkColor col;
-#endif
-    cairo_t * cr = cairo_create(c->pixmap);
-#if !GTK_CHECK_VERSION(3, 0, 0)
-    GtkStyle * style = gtk_widget_get_style(c->da);
-#endif
-    cairo_set_line_width (cr, 1.0);
-    /* Erase pixmap. */
-    cairo_rectangle(cr, 0, 0, c->pixmap_width, c->pixmap_height);
-#if GTK_CHECK_VERSION(3, 0, 0)
-    cairo_set_source_rgba(cr, c->background_color.blue,  c->background_color.green, c->background_color.red, c->background_color.alpha);
-#else
-    col.red = c->background_color.blue;
-    col.green = c->background_color.green;
-    col.blue = c->background_color.red;
-    gdk_cairo_set_source_color(cr, &col);
-#endif
-    cairo_fill(cr);
-
-    /* Recompute pixmap. */
-    unsigned int i;
-    unsigned int drawing_cursor = c->ring_cursor;
-#if GTK_CHECK_VERSION(3, 0, 0)
-    cairo_set_source_rgba(cr, c->foreground_color.blue,  c->foreground_color.green, c->foreground_color.red, c->foreground_color.alpha);
-#else
-    col.red = c->foreground_color.blue;
-    col.green = c->foreground_color.green;
-    col.blue = c->foreground_color.red;
-    gdk_cairo_set_source_color(cr, &col);
-#endif
-    for (i = 0; i < c->pixmap_width; i++)
-    {
-        /* Draw one bar of the CPU usage graph. */
-        if (c->stats_cpu[drawing_cursor] != 0.0)
-        {
-            cairo_move_to(cr, i + 0.5, c->pixmap_height);
-            cairo_line_to(cr, i + 0.5, c->pixmap_height - c->stats_cpu[drawing_cursor] * c->pixmap_height);
-            cairo_stroke(cr);
-        }
-
-        /* Increment and wrap drawing cursor. */
-        drawing_cursor += 1;
-        if (drawing_cursor >= c->pixmap_width)
-            drawing_cursor = 0;
-    }
-
-    /* draw a border in black */
-    cairo_set_source_rgb(cr, 0, 0, 0);
-    cairo_set_line_width(cr, 1);
-    cairo_move_to(cr, 0, 0);
-    cairo_line_to(cr, 0, c->pixmap_height);
-    cairo_line_to(cr, c->pixmap_width, c->pixmap_height);
-    cairo_line_to(cr, c->pixmap_width, 0);
-    cairo_line_to(cr, 0, 0);
-    cairo_stroke(cr);
-
-    if (c->show_percentage)
-    {
-        int fontsize = 12;
-        if (c->pixmap_width > 50) fontsize = c->pixmap_height / 3;
-        char buffer[10];
-        int val = 100 * c->stats_cpu[c->ring_cursor ? c->ring_cursor - 1 : c->pixmap_width - 1];
-        sprintf (buffer, "%3d %%", val);
-        cairo_select_font_face (cr, "monospace", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
-        cairo_set_font_size (cr, fontsize);
-        cairo_set_source_rgb (cr, 0, 0, 0);
-        cairo_move_to (cr, (c->pixmap_width >> 1) - ((fontsize * 5) / 3), ((c->pixmap_height + fontsize) >> 1) - 1);
-        cairo_show_text (cr, buffer);
-    }
-
-    /* check_cairo_status(cr); */
-    cairo_destroy(cr);
-
-    /* Redraw pixmap. */
-    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_data (cairo_image_surface_get_data (c->pixmap), GDK_COLORSPACE_RGB, TRUE, 8, c->pixmap_width, c->pixmap_height, c->pixmap_width *4, NULL, NULL);
-    gtk_image_set_from_pixbuf (GTK_IMAGE (c->da), pixbuf);
-    g_object_unref (pixbuf);
-}
-
 /* Periodic timer callback. */
 static gboolean cpu_update(CPUPlugin * c)
 {
     if (g_source_is_destroyed(g_main_current_source()))
         return FALSE;
-    if ((c->stats_cpu != NULL) && (c->pixmap != NULL))
-    {
         /* Open statistics file and scan out CPU usage. */
         struct cpu_stat cpu;
         char buffer[256];
@@ -202,15 +105,12 @@ static gboolean cpu_update(CPUPlugin * c)
             /* Compute user+nice+system as a fraction of total.
              * Introduce this sample to ring buffer, increment and wrap ring buffer cursor. */
             float cpu_uns = cpu_delta.u + cpu_delta.n + cpu_delta.s;
-            c->stats_cpu[c->ring_cursor] = cpu_uns / (cpu_uns + cpu_delta.i);
-            c->ring_cursor += 1;
-            if (c->ring_cursor >= c->pixmap_width)
-                c->ring_cursor = 0;
+            cpu_uns /= (cpu_uns + cpu_delta.i);
+            if (c->show_percentage) sprintf (buffer, "C:%3.0f", cpu_uns * 100.0);
+            else buffer[0] = 0;
 
-            /* Redraw with the new sample. */
-            redraw_pixmap(c);
+            graph_new_point (&(c->graph), cpu_uns, 0, buffer);
         }
-    }
     return TRUE;
 }
 
@@ -219,91 +119,8 @@ static void cpu_configuration_changed (LXPanel *panel, GtkWidget *p)
 {
     CPUPlugin *c = lxpanel_plugin_get_data (p);
 
-    /* Allocate pixmap and statistics buffer without border pixels. */
-    guint new_pixmap_height = panel_get_icon_size (panel) - (BORDER_SIZE << 1);
-    guint new_pixmap_width = (new_pixmap_height * 3) >> 1;
-    if (new_pixmap_width < 50) new_pixmap_width = 50;
-    if ((new_pixmap_width > 0) && (new_pixmap_height > 0))
-    {
-        /* If statistics buffer does not exist or it changed size, reallocate and preserve existing data. */
-        if ((c->stats_cpu == NULL) || (new_pixmap_width != c->pixmap_width))
-        {
-            CPUSample * new_stats_cpu = g_new0(typeof(*c->stats_cpu), new_pixmap_width);
-            if (c->stats_cpu != NULL)
-            {
-                if (new_pixmap_width > c->pixmap_width)
-                {
-                    /* New allocation is larger.
-                     * Introduce new "oldest" samples of zero following the cursor. */
-                    memcpy(&new_stats_cpu[0],
-                        &c->stats_cpu[0], c->ring_cursor * sizeof(CPUSample));
-                    memcpy(&new_stats_cpu[new_pixmap_width - c->pixmap_width + c->ring_cursor],
-                        &c->stats_cpu[c->ring_cursor], (c->pixmap_width - c->ring_cursor) * sizeof(CPUSample));
-                }
-                else if (c->ring_cursor <= new_pixmap_width)
-                {
-                    /* New allocation is smaller, but still larger than the ring buffer cursor.
-                     * Discard the oldest samples following the cursor. */
-                    memcpy(&new_stats_cpu[0],
-                        &c->stats_cpu[0], c->ring_cursor * sizeof(CPUSample));
-                    memcpy(&new_stats_cpu[c->ring_cursor],
-                        &c->stats_cpu[c->pixmap_width - new_pixmap_width + c->ring_cursor], (new_pixmap_width - c->ring_cursor) * sizeof(CPUSample));
-                }
-                else
-                {
-                    /* New allocation is smaller, and also smaller than the ring buffer cursor.
-                     * Discard all oldest samples following the ring buffer cursor and additional samples at the beginning of the buffer. */
-                    memcpy(&new_stats_cpu[0],
-                        &c->stats_cpu[c->ring_cursor - new_pixmap_width], new_pixmap_width * sizeof(CPUSample));
-                    c->ring_cursor = 0;
-                }
-                g_free(c->stats_cpu);
-            }
-            c->stats_cpu = new_stats_cpu;
-        }
-
-        /* Allocate or reallocate pixmap. */
-        c->pixmap_width = new_pixmap_width;
-        c->pixmap_height = new_pixmap_height;
-        if (c->pixmap)
-            cairo_surface_destroy(c->pixmap);
-        c->pixmap = cairo_image_surface_create(CAIRO_FORMAT_RGB24, c->pixmap_width, c->pixmap_height);
-        /* check_cairo_surface_status(&c->pixmap); */
-
-        /* Redraw pixmap at the new size. */
-        redraw_pixmap(c);
-    }
-}
-
-/* Handler for expose_event on drawing area. */
-#if !GTK_CHECK_VERSION(3, 0, 0)
-static gboolean expose_event(GtkWidget * widget, GdkEventExpose * event, CPUPlugin * c)
-#else
-static gboolean draw(GtkWidget * widget, cairo_t * cr, CPUPlugin * c)
-#endif
-{
-    /* Draw the requested part of the pixmap onto the drawing area.
-     * Translate it in both x and y by the border size. */
-    if (c->pixmap != NULL)
-    {
-#if !GTK_CHECK_VERSION(3, 0, 0)
-        cairo_t * cr = gdk_cairo_create(gtk_widget_get_window(widget));
-        GtkStyle * style = gtk_widget_get_style(c->da);
-        gdk_cairo_region(cr, event->region);
-        cairo_clip(cr);
-        gdk_cairo_set_source_color(cr, &c->foreground_color);
-#else
-        cairo_set_source_rgb(cr, 0, 0, 0); // FIXME: use black color from style
-#endif
-        cairo_set_source_surface(cr, c->pixmap,
-              BORDER_SIZE, BORDER_SIZE);
-        cairo_paint(cr);
-        /* check_cairo_status(cr); */
-#if !GTK_CHECK_VERSION(3, 0, 0)
-        cairo_destroy(cr);
-#endif
-    }
-    return FALSE;
+    GdkRGBA none = {0, 0, 0, 0};
+    graph_reload (&(c->graph), panel_get_safe_icon_size (panel), c->background_color, c->foreground_color, none, none);
 }
 
 /* Plugin constructor. */
@@ -351,20 +168,13 @@ static GtkWidget *cpu_constructor(LXPanel *panel, config_setting_t *settings)
     lxpanel_plugin_set_data(p, c, cpu_destructor);
 
     /* Allocate drawing area as a child of top level widget. */
-    c->da = gtk_image_new();
-    gtk_widget_add_events(c->da, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+    gtk_widget_add_events(c->graph.da, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
                                  GDK_BUTTON_MOTION_MASK);
-    gtk_container_add(GTK_CONTAINER(p), c->da);
-
-    /* Connect signals. */
-#if !GTK_CHECK_VERSION(3, 0, 0)
-    g_signal_connect(G_OBJECT(c->da), "expose-event", G_CALLBACK(expose_event), (gpointer) c);
-#else
-    g_signal_connect(G_OBJECT(c->da), "draw", G_CALLBACK(draw), (gpointer) c);
-#endif
+    graph_init (&(c->graph));
+    gtk_container_add (GTK_CONTAINER (p), c->graph.da);
 
     /* Show the widget.  Connect a timer to refresh the statistics. */
-    gtk_widget_show(c->da);
+    gtk_widget_show(c->graph.da);
     cpu_configuration_changed (panel,p);
     c->timer = g_timeout_add(1500, (GSourceFunc) cpu_update, (gpointer) c);
     return p;
@@ -379,8 +189,7 @@ static void cpu_destructor(gpointer user_data)
     g_source_remove(c->timer);
 
     /* Deallocate memory. */
-    cairo_surface_destroy(c->pixmap);
-    g_free(c->stats_cpu);
+    graph_free (&(c->graph));
     g_free(c);
 }
 
diff --git a/src/plugin.c b/src/plugin.c
index b5109a4..7cd7320 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -705,3 +705,204 @@ const char *lxpanel_plugin_get_menu_label (GtkWidget *item)
     }
     return "";
 }
+
+/*----------------------------------------------------------------------------*/
+/* Plugin graph */
+/*----------------------------------------------------------------------------*/
+
+/* Redraw entire graph */
+
+static void graph_redraw (PluginGraph *graph, char *label)
+{
+    unsigned int fontsize, drawing_cursor, i;
+    GdkPixbuf *pixbuf;
+
+    cairo_t *cr = cairo_create (graph->pixmap);
+    cairo_set_line_width (cr, 1.0);
+
+    /* Erase pixmap */
+    cairo_rectangle (cr, 0, 0, graph->pixmap_width, graph->pixmap_height);
+    cairo_set_source_rgba (cr, graph->background.blue, graph->background.green, graph->background.red, graph->background.alpha);
+    cairo_fill (cr);
+
+    /* Recompute pixmap */
+    drawing_cursor = graph->ring_cursor;
+    for (i = 0; i < graph->pixmap_width; i++)
+    {
+        /* Draw one bar of the graph. */
+        if (graph->samples[drawing_cursor] != 0.0)
+        {
+            cairo_set_source_rgba (cr, graph->colours[graph->samp_states[drawing_cursor]].blue, graph->colours[graph->samp_states[drawing_cursor]].green,
+                graph->colours[graph->samp_states[drawing_cursor]].red, graph->colours[graph->samp_states[drawing_cursor]].alpha);
+
+            cairo_move_to (cr, i + 0.5, graph->pixmap_height);
+            cairo_line_to (cr, i + 0.5, graph->pixmap_height - graph->samples[drawing_cursor] * graph->pixmap_height);
+            cairo_stroke (cr);
+        }
+
+        /* Increment and wrap drawing cursor */
+        drawing_cursor += 1;
+        if (drawing_cursor >= graph->pixmap_width) drawing_cursor = 0;
+    }
+
+    /* Draw border in black */
+    cairo_set_source_rgb (cr, 0, 0, 0);
+    cairo_set_line_width (cr, 1);
+    cairo_move_to (cr, 0, 0);
+    cairo_line_to (cr, 0, graph->pixmap_height);
+    cairo_line_to (cr, graph->pixmap_width, graph->pixmap_height);
+    cairo_line_to (cr, graph->pixmap_width, 0);
+    cairo_line_to (cr, 0, 0);
+    cairo_stroke (cr);
+
+    /* Apply label */
+    fontsize = 12;
+    if (graph->pixmap_width > 50) fontsize = graph->pixmap_height / 3;
+    cairo_select_font_face (cr, "monospace", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
+    cairo_set_font_size (cr, fontsize);
+    cairo_set_source_rgb (cr, 0, 0, 0);
+    cairo_move_to (cr, (graph->pixmap_width >> 1) - ((fontsize * 5) / 4), ((graph->pixmap_height + fontsize) >> 1) - 1);
+    cairo_show_text (cr, label);
+
+    cairo_destroy (cr);
+
+    /* Update image */
+    pixbuf = gdk_pixbuf_new_from_data (cairo_image_surface_get_data (graph->pixmap), GDK_COLORSPACE_RGB, TRUE, 8,
+        graph->pixmap_width, graph->pixmap_height, graph->pixmap_width * 4, NULL, NULL);
+    gtk_image_set_from_pixbuf (GTK_IMAGE (graph->da), pixbuf);
+}
+
+/* Initialise graph for a particular size */
+
+void graph_reload (PluginGraph *graph, int icon_size, GdkRGBA background, GdkRGBA foreground, GdkRGBA throttle1, GdkRGBA throttle2)
+{
+    /* Load colours */
+    graph->background = background;
+    graph->colours[0] = foreground;
+    graph->colours[1] = throttle1;
+    graph->colours[2] = throttle2;
+
+    /* Allocate pixmap and statistics buffer without border pixels. */
+    guint new_pixmap_height = icon_size - (BORDER_SIZE << 1);
+    guint new_pixmap_width = (new_pixmap_height * 3) >> 1;
+    if (new_pixmap_width < 50) new_pixmap_width = 50;
+
+    if ((new_pixmap_width > 0) && (new_pixmap_height > 0))
+    {
+        /* If statistics buffer does not exist or it changed size, reallocate and preserve existing data. */
+        if ((graph->samples == NULL) || (new_pixmap_width != graph->pixmap_width))
+        {
+            float *new_samples = g_new0 (float, new_pixmap_width);
+            int *new_samp_states = g_new0 (int, new_pixmap_width);
+            if (graph->samples != NULL)
+            {
+                if (new_pixmap_width > graph->pixmap_width)
+                {
+                    /* New allocation is larger. Introduce new "oldest" samples of zero following the cursor. */
+                    memcpy (&new_samples[0], &graph->samples[0], graph->ring_cursor * sizeof (float));
+                    memcpy (&new_samples[new_pixmap_width - graph->pixmap_width + graph->ring_cursor], &graph->samples[graph->ring_cursor], (graph->pixmap_width - graph->ring_cursor) * sizeof (float));
+                    memcpy (&new_samp_states[0], &graph->samp_states[0], graph->ring_cursor * sizeof (int));
+                    memcpy (&new_samp_states[new_pixmap_width - graph->pixmap_width + graph->ring_cursor], &graph->samp_states[graph->ring_cursor], (graph->pixmap_width - graph->ring_cursor) * sizeof (int));
+                }
+                else if (graph->ring_cursor <= new_pixmap_width)
+                {
+                    /* New allocation is smaller, but still larger than the ring buffer cursor. Discard the oldest samples following the cursor. */
+                    memcpy (&new_samples[0], &graph->samples[0], graph->ring_cursor * sizeof (float));
+                    memcpy (&new_samples[graph->ring_cursor], &graph->samples[graph->pixmap_width - new_pixmap_width + graph->ring_cursor], (new_pixmap_width - graph->ring_cursor) * sizeof (float));
+                    memcpy (&new_samp_states[0], &graph->samp_states[0], graph->ring_cursor * sizeof (int));
+                    memcpy (&new_samp_states[graph->ring_cursor], &graph->samp_states[graph->pixmap_width - new_pixmap_width + graph->ring_cursor], (new_pixmap_width - graph->ring_cursor) * sizeof (int));
+                }
+                else
+                {
+                    /* New allocation is smaller, and also smaller than the ring buffer cursor. Discard all oldest samples following the ring buffer cursor and additional samples at the beginning of the buffer. */
+                    memcpy (&new_samples[0], &graph->samples[graph->ring_cursor - new_pixmap_width], new_pixmap_width * sizeof (float));
+                    memcpy (&new_samp_states[0], &graph->samp_states[graph->ring_cursor - new_pixmap_width], new_pixmap_width * sizeof (int));
+                    graph->ring_cursor = 0;
+                }
+                g_free (graph->samples);
+                g_free (graph->samp_states);
+            }
+            graph->samples = new_samples;
+            graph->samp_states = new_samp_states;
+        }
+
+        /* Allocate or reallocate pixmap. */
+        graph->pixmap_width = new_pixmap_width;
+        graph->pixmap_height = new_pixmap_height;
+        if (graph->pixmap) cairo_surface_destroy (graph->pixmap);
+        graph->pixmap = cairo_image_surface_create (CAIRO_FORMAT_RGB24, graph->pixmap_width, graph->pixmap_height);
+
+        /* Redraw pixmap at the new size. */
+        graph_redraw (graph, "");
+    }
+}
+
+/* Add new data point to the graph */
+
+void graph_new_point (PluginGraph *graph, float value, int state, char *label)
+{
+    if (value < 0.0) value = 0.0;
+    else if (value > 1.0) value = 1.0;
+    graph->samples[graph->ring_cursor] = value;
+    graph->samp_states[graph->ring_cursor] = state;
+
+    graph->ring_cursor += 1;
+    if (graph->ring_cursor >= graph->pixmap_width) graph->ring_cursor = 0;
+
+    graph_redraw (graph, label);
+}
+
+void graph_init (PluginGraph *graph)
+{
+    graph->da = gtk_image_new ();
+    graph->samples = NULL;
+    graph->ring_cursor = 0;
+    graph->pixmap = NULL;
+}
+
+void graph_free (PluginGraph *graph)
+{
+    if (graph->pixmap) cairo_surface_destroy (graph->pixmap);
+    if (graph->samples) g_free (graph->samples);
+    if (graph->samp_states) g_free (graph->samp_states);
+    gtk_widget_destroy (graph->da);
+}
+
+/*----------------------------------------------------------------------------*/
+/* Click-away pop-up */
+/*----------------------------------------------------------------------------*/
+
+static gboolean popup_mapped (GtkWidget *widget, GdkEvent *, gpointer)
+{
+    gdk_seat_grab (gdk_display_get_default_seat (gdk_display_get_default ()), gtk_widget_get_window (widget), GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE, NULL, NULL, NULL, NULL);
+    return FALSE;
+}
+
+static gboolean popup_button_press (GtkWidget *widget, GdkEventButton *event, gpointer)
+{
+    int x, y;
+    gtk_window_get_size (GTK_WINDOW (widget), &x, &y);
+    if (event->x < 0 || event->y < 0 || event->x > x || event->y > y)
+    {
+        if (widget) gtk_widget_destroy (widget);
+        gdk_seat_ungrab (gdk_display_get_default_seat (gdk_display_get_default ()));
+    }
+    return FALSE;
+}
+
+void popup_at_button (LXPanel *panel, GtkWidget *window, GtkWidget *button, gpointer plugin)
+{
+    gint x, y;
+    gtk_window_set_decorated (GTK_WINDOW (window), FALSE);
+    gtk_window_set_type_hint (GTK_WINDOW (window), GDK_WINDOW_TYPE_HINT_POPUP_MENU);
+    gtk_window_set_skip_taskbar_hint (GTK_WINDOW (window), TRUE);
+    gtk_window_set_position (GTK_WINDOW (window), GTK_WIN_POS_MOUSE);
+    gtk_widget_show_all (window);
+    gtk_widget_hide (window);
+    lxpanel_plugin_popup_set_position_helper (panel, button, window, &x, &y);
+    gtk_widget_show_all (window);
+    gtk_window_present (GTK_WINDOW (window));
+    gdk_window_move (gtk_widget_get_window (window), x, y);
+    g_signal_connect (G_OBJECT (window), "map-event", G_CALLBACK (popup_mapped), plugin);
+    g_signal_connect (G_OBJECT (window), "button-press-event", G_CALLBACK (popup_button_press), plugin);
+}
diff --git a/src/plugin.h b/src/plugin.h
index 244febe..f752218 100644
--- a/src/plugin.h
+++ b/src/plugin.h
@@ -396,6 +396,37 @@ extern void lxpanel_notify_init (LXPanel *panel);
 extern int lxpanel_notify (LXPanel *panel, char *message);
 extern void lxpanel_notify_clear (int seq);
 
+#define BORDER_SIZE 2
+
+typedef struct {
+    GtkWidget *da;                          /* Drawing area */
+    cairo_surface_t *pixmap;                /* Pixmap to be drawn on drawing area */
+    float *samples;                         /* Ring buffer of values */
+    int *samp_states;                       /* Ring buffer of states used for colours */
+    unsigned int ring_cursor;               /* Cursor for ring buffer */
+    guint pixmap_width;                     /* Width of drawing area pixmap; also size of ring buffer; does not include border size */
+    guint pixmap_height;                    /* Height of drawing area pixmap; does not include border size */
+    GdkRGBA background;                     /* Graph background colour */
+    GdkRGBA colours[3];                     /* Graph foreground colours - normal and throttled */
+} PluginGraph;
+
+extern void graph_init (PluginGraph *graph);
+extern void graph_reload (PluginGraph *graph, int icon_size, GdkRGBA background, GdkRGBA foreground, GdkRGBA throttle1, GdkRGBA throttle2);
+extern void graph_new_point (PluginGraph *graph, float value, int state, char *label);
+extern void graph_free (PluginGraph *graph);
+
+extern void popup_at_button (LXPanel *panel, GtkWidget *window, GtkWidget *button, gpointer plugin);
+
+#define wrap_new_menu_item(plugin,text,maxlen,icon) lxpanel_plugin_new_menu_item(plugin->panel,text,maxlen,icon)
+#define wrap_set_menu_icon(plugin,image,icon) lxpanel_plugin_set_menu_icon(plugin->panel,image,icon)
+#define wrap_set_taskbar_icon(plugin,image,icon) lxpanel_plugin_set_taskbar_icon(plugin->panel,image,icon)
+#define wrap_get_menu_label(item) lxpanel_plugin_get_menu_label(item)
+#define wrap_show_menu(plugin,menu) gtk_menu_popup_at_widget(GTK_MENU(menu),plugin,GDK_GRAVITY_SOUTH_WEST,GDK_GRAVITY_NORTH_WEST,NULL)
+#define wrap_icon_size(plugin) panel_get_safe_icon_size(plugin->panel)
+#define wrap_is_at_bottom(plugin) panel_is_at_bottom(plugin->panel)
+#define wrap_popup_at_button(plugin,window,button) popup_at_button(plugin->panel,window,button,plugin)
+#define CHECK_LONGPRESS
+
 G_END_DECLS
 
 #undef _
